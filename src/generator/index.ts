/**
 * Generator - Transforms Memory into Markdown files for VitePress
 *
 * Outputs:
 * - Markdown files organized by category
 * - VitePress configuration for navigation
 * - Index page with overview
 */

import * as fs from "node:fs/promises";
import * as path from "node:path";
import type { AgentConfig, DocCategory, DocSection, Memory } from "../types.js";

interface SidebarItem {
  text: string;
  link?: string;
  items?: SidebarItem[];
}

export class Generator {
  private config: AgentConfig;

  constructor(config: AgentConfig) {
    this.config = config;
  }

  async generate(memory: Memory): Promise<void> {
    const outputDir = path.resolve(this.config.outputDir);

    // Create directory structure
    await this.createDirectories(outputDir);

    // Group sections by category
    const sectionsByCategory = this.groupByCategory(memory.documentSections);

    // Write markdown files for each section
    for (const section of memory.documentSections) {
      await this.writeMdFile(outputDir, section);
    }

    // Generate index.md
    await this.generateIndexMd(outputDir, memory, sectionsByCategory);

    // Generate VitePress config
    await this.generateVitePressConfig(outputDir, memory, sectionsByCategory);
  }

  private async createDirectories(outputDir: string): Promise<void> {
    const dirs = [
      outputDir,
      path.join(outputDir, ".vitepress"),
      path.join(outputDir, "overview"),
      path.join(outputDir, "architecture"),
      path.join(outputDir, "modules"),
      path.join(outputDir, "api"),
      path.join(outputDir, "guide"),
    ];

    for (const dir of dirs) {
      await fs.mkdir(dir, { recursive: true });
    }
  }

  private groupByCategory(sections: DocSection[]): Record<DocCategory, DocSection[]> {
    const groups: Record<DocCategory, DocSection[]> = {
      overview: [],
      architecture: [],
      module: [],
      api: [],
      guide: [],
      other: [],
    };

    for (const section of sections) {
      groups[section.category].push(section);
    }

    return groups;
  }

  private getCategoryDir(category: DocCategory): string {
    const dirMap: Record<DocCategory, string> = {
      overview: "overview",
      architecture: "architecture",
      module: "modules",
      api: "api",
      guide: "guide",
      other: "other",
    };
    return dirMap[category];
  }

  private async writeMdFile(outputDir: string, section: DocSection): Promise<void> {
    const categoryDir = this.getCategoryDir(section.category);
    const fileName = this.sanitizeFileName(section.title) + ".md";
    const filePath = path.join(outputDir, categoryDir, fileName);

    // Add frontmatter and content
    const content = `---
title: ${section.title}
---

${section.content}
`;

    await fs.writeFile(filePath, content);
  }

  private sanitizeFileName(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fff]+/g, "-") // Keep Chinese characters
      .replace(/^-+|-+$/g, "")
      .slice(0, 50);
  }

  private async generateIndexMd(
    outputDir: string,
    memory: Memory,
    sectionsByCategory: Record<DocCategory, DocSection[]>,
  ): Promise<void> {
    const overviewSection = sectionsByCategory.overview[0];

    const categories = (["overview", "architecture", "module", "api", "guide"] as DocCategory[])
      .filter((cat) => sectionsByCategory[cat].length > 0);

    // Link to first document in each category instead of directory
    const categoryLinks = categories
      .map((cat) => {
        const firstSection = sectionsByCategory[cat][0];
        const link = `/${this.getCategoryDir(cat)}/${this.sanitizeFileName(firstSection.title)}`;
        return `- [${this.getCategoryTitle(cat)}](${link})`;
      })
      .join("\n");

    const insights = memory.insights.length > 0
      ? `\n## Key Insights\n\n${memory.insights.map((i) => `- ${i}`).join("\n")}\n`
      : "";

    // Determine the "Get Started" link - use first category's first doc
    const firstCategory = categories[0];
    const firstDoc = sectionsByCategory[firstCategory][0];
    const getStartedLink = `/${this.getCategoryDir(firstCategory)}/${this.sanitizeFileName(firstDoc.title)}`;

    const content = `---
layout: home
hero:
  name: Documentation
  tagline: Generated by Moles
  actions:
    - theme: brand
      text: Get Started
      link: ${getStartedLink}
---

${overviewSection ? overviewSection.content : "Welcome to the documentation."}

## Sections

${categoryLinks}
${insights}
`;

    await fs.writeFile(path.join(outputDir, "index.md"), content);
  }

  private async generateVitePressConfig(
    outputDir: string,
    memory: Memory,
    sectionsByCategory: Record<DocCategory, DocSection[]>,
  ): Promise<void> {
    const sidebar = this.buildSidebar(sectionsByCategory);

    const config = `import { defineConfig } from 'vitepress'

export default defineConfig({
  title: 'Documentation',
  description: 'Generated by Moles',
  themeConfig: {
    sidebar: ${JSON.stringify(sidebar, null, 6)},
    socialLinks: [
      { icon: 'github', link: 'https://github.com' }
    ],
    footer: {
      message: 'Generated by Moles - AI Documentation Agent'
    }
  }
})
`;

    await fs.writeFile(path.join(outputDir, ".vitepress", "config.ts"), config);
  }

  private buildSidebar(sectionsByCategory: Record<DocCategory, DocSection[]>): SidebarItem[] {
    const categories = (["overview", "architecture", "module", "api", "guide"] as DocCategory[])
      .filter((cat) => sectionsByCategory[cat].length > 0);

    return categories.map((cat) => ({
      text: this.getCategoryTitle(cat),
      items: sectionsByCategory[cat].map((section) => ({
        text: section.title,
        link: `/${this.getCategoryDir(cat)}/${this.sanitizeFileName(section.title)}`,
      })),
    }));
  }

  private getCategoryTitle(category: DocCategory): string {
    const titles: Record<DocCategory, string> = {
      overview: "Overview",
      architecture: "Architecture",
      module: "Modules",
      api: "API Reference",
      guide: "Guides",
      other: "Other",
    };
    return titles[category];
  }
}
